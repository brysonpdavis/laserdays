using UnityEngine;  namespace MFPP.Modules {     [HelpURL("https://ashkoredracson.github.io/MFPP/#pick-up-module")]     public class PickUpModule : PlayerModule     {         /// <summary>         /// The maximum pickup distance.         /// </summary>         [Space]         [Tooltip("The maximum pickup distance.")]         public float MaxPickupDistance = 2f;         public float breakDistance = 5f;         /// <summary>         /// Pick up button.         /// </summary>         [Tooltip("Pick up button.")]         public string PickUpButton = "Pick Up";         private float originalWalkingSpeed = 3;         [SerializeField] private LayerMask newLayerMask;         private Vector3 sokobanPosition;            //OUR VARIABLES [will]         public Transform player;         public Transform playerCam;         private Camera mainCamera;         public GameObject heldObject;         private PlayerCharge pc;          void Start () {             mainCamera = Camera.main;             pc = GetComponent<PlayerCharge>();          }          private Rigidbody target;          public override void AfterUpdate()         {             if (Input.GetButtonDown(PickUpButton)) // If pick up button was pressed             {                 if (target) // If we already have a target rigidbody, set it to null, thus dropping/throwing it.                 {                     PutDown();                 }                 else                 {                     //FOR LATER: not sure this is totally working (why I'm checking rigidbody's layer vs. player's layer right before the pickup)                     if (this.gameObject.layer == 15) { newLayerMask.value = 1024; } //layermask value of layer 10 is 1024                     else if (this.gameObject.layer == 16) { newLayerMask.value = 2048; } //layermask value of layer 11 is 2048                      Ray r = new Ray(mainCamera.transform.position, mainCamera.transform.forward);                     RaycastHit hit;                     if (Physics.Raycast(r, out hit, MaxPickupDistance, newLayerMask.value)) // Otherwise, if target was null, shoot a ray where we are aiming.                     {                           Rigidbody body = hit.collider.attachedRigidbody;                          if (body && !body.isKinematic && !body.CompareTag("MorphOff") && ((body.gameObject.layer + 5) == this.gameObject.layer ) )                             // Retreive the rigidbody and assure that it is not kinematic, and that it's not an unwanted obj type                             //checking object's layer once more, wasn't working for morphs using normal layermask                         {                             PickUp(body);                             //do thing with morph on here to get ready for potential flip                          }                     }                      //check if the object is already selected, remove it from list                     if (heldObject && heldObject.GetComponent<ItemProperties>().selected)                     {                         RaycastManager rm = GetComponent<RaycastManager>();                         rm.RemoveFromList(target.gameObject, true);                         rm.selectedObjs.Remove(target.gameObject);                           //keep the shader in selected mode though the object is off the list                         if (!heldObject.CompareTag("MorphOn")) {                                                          heldObject.GetComponent<Renderer>().material.SetInt("_IsSelected", 1);                             }                          else {                             rm.RemoveFromList(target.GetComponent<Morph>().associatedMorph, true);                             rm.selectedObjs.Remove(target.GetComponent<Morph>().associatedMorph);                         }                           pc.UpdatePredictingSlider();                     }                 }             }              if (target) // If target is not null, move the target in front of the camera at max pickup distance.
            {
                //AVOIDING FLYING ON TOP OF HELD OBJECT GLITCH:
                //checks rotation of player so that it's down (the between the 67 and 91f)
                //checks that the player is actually looking at OBJECT, (colored crosshair), rather than looking at ground while object is distant
                if ((playerCam.transform.localEulerAngles.x > 65f) && (playerCam.transform.localEulerAngles.x < 91f) && GetComponent<RaycastManager>().crossHair.color == new Color32(255, 222, 77, 255))                 {                     PutDown();                 }                  else  {                 if (!target.CompareTag("Sokoban") && !target.CompareTag("MorphOn") && !target.CompareTag("MorphOff"))
                    {
                        Vector3 floatingPosition = mainCamera.transform.position + mainCamera.transform.forward * MaxPickupDistance;
                        target.angularVelocity *= 0.5f;
                        target.velocity = ((floatingPosition - target.transform.position) * 10f);
                    }

                    else
                    {
                        Vector3 floatingPosition = this.transform.position + (sokobanPosition + mainCamera.transform.forward);
                        target.angularVelocity *= 0.5f;
                        target.velocity = ((floatingPosition - target.transform.position) * 10f);
                    }



                    //make sure you can't hold the object while too far away
                    if (Mathf.Abs(Vector3.Distance(player.transform.position, target.transform.position)) > breakDistance)
                    {

                        PutDown();
                    }
                }             }         }          public void PickUp (Rigidbody body) {             target = body; // Set the target             sokobanPosition = body.transform.position - (this.transform.position + mainCamera.transform.forward);             heldObject = target.gameObject;             target.useGravity = false;              if (target.CompareTag("Clickable"))
            {
                target.freezeRotation = true;                 RaycastManager rm = GetComponent<RaycastManager>();                 //heldObject.GetComponent<Renderer>().material.shader = rm.shaderselected;                 heldObject.GetComponent<Renderer>().material.SetInt("_IsSelected", 1);
                           }              if (target.CompareTag("Sokoban") )             {                 target.constraints = RigidbodyConstraints.None;                 target.constraints = RigidbodyConstraints.FreezePositionY | RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ | RigidbodyConstraints.FreezeRotationY;                 RaycastManager rm = GetComponent<RaycastManager>();                 heldObject.GetComponent<Renderer>().material.shader = rm.shaderselected; //TODO: change this to sokobanSelected when there is one!!             }              if (target.CompareTag("MorphOn"))             {                 target.GetComponent<Morph>().OnPickup(); //do what's supposed to happen to associated morph when pickup occurs                 target.constraints = RigidbodyConstraints.None;                 target.constraints = RigidbodyConstraints.FreezePositionY | RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ | RigidbodyConstraints.FreezeRotationY;                 RaycastManager rm = GetComponent<RaycastManager>();                // heldObject.GetComponent<Renderer>().material.shader = rm.morphShaderselected;                 //for when we have one!             }               pc.UpdatePredictingSlider();              //changing player's walking based on target's mass             if (target.mass > 2 && target.mass < 3){                 player.GetComponent<Player>().Movement.Speed = 1;             }              if (target.mass >= 3)             {                 player.GetComponent<Player>().Movement.Speed = 1;                 player.GetComponent<Player>().Movement.Jump.Power = 0;              }          }          public void PutDown () {                          GetComponent<MFPP.Player>().Movement.AllowMouseMove = true;              RaycastManager rm = GetComponent<RaycastManager>();             if (heldObject.CompareTag("Clickable")){                  //put the object down with the right shader                 if (player.GetComponent<flipScript>().space)                 {heldObject.GetComponent<Renderer>().material.shader = rm.realWorldShader;                     heldObject.GetComponent<Renderer>().material.SetInt("_IsSelected", 0);                     heldObject.layer = 11;                     heldObject.GetComponent<Transition>().SetStart(0f);  }                  else                 {heldObject.GetComponent<Renderer>().material.shader = rm.laserWorldShader;                     heldObject.GetComponent<Renderer>().material.SetInt("_IsSelected", 0);                     heldObject.layer = 10;                     heldObject.GetComponent<Transition>().SetStart(1f);}                  target.freezeRotation = false;
                target.useGravity = true;             }              if (heldObject.CompareTag("Sokoban"))
            {                                  if (player.GetComponent<flipScript>().space)                 { heldObject.GetComponent<Renderer>().material.shader = rm.realWorldShader;                     heldObject.layer = 11;                     heldObject.GetComponent<Transition>().SetStart(0f);}                  else                 { heldObject.GetComponent<Renderer>().material.shader = rm.laserWorldShader;                     heldObject.layer = 10;                     heldObject.GetComponent<Transition>().SetStart(1f);}                  target.freezeRotation = false;                 target.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezeAll;                 target.useGravity = true;

            }              if (heldObject.CompareTag("MorphOn"))             {                  float morphCheck = heldObject.GetComponent<Renderer>().material.GetFloat("_TransitionStateB");                  if (!(morphCheck > 0f && morphCheck < 1f))
                {

                    target.GetComponent<Morph>().OnPutDown(); //do what's supposed to happen to associated morph when putdown occurs                  if (player.GetComponent<flipScript>().space)
                    {
                        heldObject.GetComponent<Renderer>().material.shader = rm.morphRealWorldShader;
                        heldObject.layer = 11;
                        heldObject.GetComponent<Transition>().SetStart(0f);
                    }

                    else
                    {
                        heldObject.GetComponent<Renderer>().material.shader = rm.morphLaserWorldShader;
                        heldObject.layer = 10;
                        heldObject.GetComponent<Transition>().SetStart(1f);
                    }                 }                  target.freezeRotation = false;                 target.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezeAll;                 target.useGravity = true;              }              heldObject.GetComponent<ItemProperties>().selected = false;             heldObject = null; //remove from the list             target = null;             pc.UpdatePredictingSlider();                  //resets player's walking speed movement, jump             player.GetComponent<Player>().Movement.Speed = 3;             player.GetComponent<Player>().Movement.Jump.Power = 4.2f;           }     } }  